//
//  Dependencies.swift
//
//
//  Created by √ìscar Morales Viv√≥ on 1/11/23.
//

import Foundation

/**
 Base protocol for dependency injection. It establishes the baseline for building up dependency sub-protocols with
 facilities for overwriting dependencies and instantiating new dependency objects for other types without having
 to drag all dependencies through the app tree.

 Each global service/singleton in use should make itself available through dependency injection by doing the following:
 - Declare a protocol `Sample` (replace `Sample` with whatever makes sense for naming the protocol). Don't suffix
 the protocol name with `Protocol`. The protocol will declare the API that will be visible to the rest of the
 components.
 - Declare a protocol that implements `Dependencies`, for consistency for `Sample` we should name it
 `SampleDependency`. Make sure it's not a generic protocol. It should look like the following:
 ```swift
 protocol SampleDependency: Dependencies {
     var sample: any Sample { get }
 }
 ```
 - Build a default implementation that will be the one in normal use. Let's call this one `DefaultSample`, but there's
 no particular need to adhere to a specific naming convention for it.
 - Declare a dependency key value type that adopts `DependencyKey`. Following along our sample dependency, this is how
 it would look like:
 ```swift
 struct SampleDependencyKey: DependencyKey {
     let defaultValue: any Sample = DefaultSample()
 }
 ```
 - Declare an extension to `GlobalDependencies` that implements `SampleDependency`. The implementation should look as
 follows:
 ```swift
 extension GlobalDependencies: SampleDependency {
     var sample: any Sample {
         return resolveDependency(forKey: SampleDependencyKey.self)
     }
 }
 ```

 Adoption of dependency injection by the various components of the app should be accomplished as follows:
 - Declare a private constant to hold onto the dependencies. This constant should **not** be of type
 `GlobalDependencies` but instead be a union of all the dependencies that the component needs to perform. For example,
 if our component `MyComponent` needs access to `Network` and `Settings`, it will declare its dependencies as follows:
 ```swift
 class MyComponent ... {
     private let dependencies: NetworkDependency & SettingsDependency
 }
 ```
 - This ensures that we keep the dependencies for a given component explicity managed. If you try to use a different one
 you'll need to add its protocol to the dependencies property type, and hopefully you'll give some thought about whether
 you actually need it.
 - Additionally, the component initializer should allow for a dependency parameter, which _should_ be of type
 `GlobalDependencies`. It ought to have a default value of `GlobalDependencies.default`. Example for the above:
 ```swift
 class MyComponent ... {
     init( ... , dependencies: GlobalDependencies = .default) {
         self.dependencies = dependencies
         ...
     }
 }
 ```
 - Use of dependencies within the component is done by just accessing them through the private `dependencies` property.
 - If the component builds other subcomponents ‚Äîi.e. a view controller presenting another one, or a general model
 building up an object that manages a smaller part, it should pass in its own dependencies, calling `buildGlobal` to
 type-shift them to something that the other component can take. This ensures that overwritten dependencies consistenly
 get passed down to other components. For example:
 ```swift
 class MyComponent ... {
     func doThing(...) {
         ...
         let subComponent = SubComponent( ... , dependencies: dependencies.buildGlobal())
         ...
     }
 }
 ```
 */
public protocol Dependencies {
    /// Build a new ``GlobalDependencies`` from any ``Dependencies``.
    func buildGlobal() -> GlobalDependencies
}

/**
 A macro that sets up a dependency based on the protocol it is attached to.

 Due to limitations of the Swift macro system (as of Swift 5.9) it is better to have a 1 to 1 correspondence between a
 protocol and a dependency type. So your protocol `MyService` will have a dependency accessor called `myService` of type
 `any MyService` for those types that declare the protocol in their `Dependencies`

 Most of the time that will be fine but if not you can always declare a different protocol that just adopts the former
 one and apply this macro to it. This will also allow continued use of the `Dependencies` macro, which wouldn't work
 with a manual dependency declaration named differently than the protocol it's based on.

 If despite all the above a manual dependency declaration is needed you can find instructions in the package
 documentation and you can always just check the code generated by the macro when applied to any protocol (there's not
 a whole lot of it).
 - Parameters
   - lowercased: Optional name of the dependency access property, to be used if it is different than `name` with its
 first letter in lowercase.
   - defaultValueType: The type of the default value for the dependency. Must have an initializer with no parameters.
 */
@attached(peer, names: suffixed(Dependency), suffixed(DependencyKey))
@attached(member, names: named(Dependency), named(DependencyKey))
public macro Dependency<T>(lowercased: StaticString? = nil, defaultValueType: T.Type) = #externalMacro(
    module: "GlobalDependenciesMacros",
    type: "DependencyPeers"
)

/**
 Variant of the `Dependency` macro does not take a default value type.

 If the default value type for the dependency implementation is named `Default<ProtocolName>` you can use this variant
 of the macro and it will catch on it.

 Because there is no generic argument it has to be declared separately from the version with a default value type as
 the compiler wouldn't know what type to use without the presence of the parameter that uses it.

 Otherwise the documentation of the fully featured macro applies to its behavior.
 - Parameters
   - lowercased: Optional name of the dependency access property, to be used if it is different than `name` with its
 first letter in lowercase.
 */
@attached(peer, names: suffixed(Dependency), suffixed(DependencyKey))
@attached(member, names: named(Dependency), named(DependencyKey))
public macro Dependency(lowercased: StaticString? = nil) = #externalMacro(
    module: "GlobalDependenciesMacros",
    type: "DependencyPeers"
)

/**
 Implements a dependency on the `GlobalDependencies` type.

 Since Swift macros cannot (as of Swift 5.9) declare extensions, this macro will be invoked _inside_ a manually declared
  `extension GlobalDependencies: MyServiceDependency`. And since the macro doesn't have access to its contextual
 semantics you'll have to repeat the protocol name in the corresponding parameter of the macro ü§∑üèΩ‚Äç‚ôÇÔ∏è.
 - Parameters
   - type: Type of the dependency. Should be the same as the property vended by the dependency protocol that the
 extension is adopting.
   - lowercased: Name of the dependency accessor property. You only need to pass a value if it is different than `name`
 with its first letter lowercased.
 */
@freestanding(declaration, names: arbitrary)
public macro GlobalDependency<T>(type: T.Type, lowercased: StaticString? = nil) = #externalMacro(
    module: "GlobalDependenciesMacros",
    type: "GlobalDependencyImplementation"
)

/**
 A macro that declares the dependencies of the attached type and sets it up for injection.

 The macro will declare a `Dependencies` type matching the dependencies for all the given protocols and a
 `private let dependencies: Dependencies` stored property to hold onto them.

 Initialization being individual to each type means injecting the dependencies will need happen manually, usually by.
 adding a final parameter of the form `dependencies: Dependencies = GlobalDependencies.default` in your initializers.
 - Parameter _: A comma-separated list of dependency protocols. These should be the protocols that have `@Dependency`
 attached to their declaration, not the generated `*Dependency` protocols
 */
@attached(member, names: named(Dependencies), named(dependencies))
public macro Dependencies<each U>(_: repeat (each U).Type) = #externalMacro(
    module: "GlobalDependenciesMacros",
    type: "TypeDependencies"
)
