//
//  Dependency.swift
//
//
//  Created by Óscar Morales Vivó on 11/7/23.
//

import Foundation

/**
 A macro that sets up a dependency based on the protocol it is attached to.

 Due to limitations of the Swift macro system (as of Swift 5.9) it is better to have a 1 to 1 correspondence between a
 protocol and a dependency type. So your protocol `MyService` will have a dependency accessor called `myService` of type
 `any MyService` for those types that declare the protocol in their `Dependencies`

 Most of the time that will be fine but if not you can always declare a different protocol that just adopts the former
 one and apply this macro to it. This will also allow continued use of the `Dependencies` macro, which wouldn't work
 with a manual dependency declaration named differently than the protocol it's based on.

 If despite all the above a manual dependency declaration is needed you can find instructions in the package
 documentation and you can always just check the code generated by the macro when applied to any protocol (there's not
 a whole lot of it).
 - Parameters
   - lowercased: Optional name of the dependency access property, to be used if it is different than `name` with its
 first letter in lowercase.
   - defaultValueFactory: A type that adopts `DefaultValueFactory` and whose `Value` associated type adopts the protocol
 that the macro is attached to. The latter constraint can't be modeled in the macro declaration as of Swift 5.9 but
 compilation will fail if that's not the case.
 */
@attached(peer, names: suffixed(Dependency), suffixed(DependencyKey))
@attached(member, names: named(Dependency), named(DependencyKey))
public macro Dependency<T: DefaultDependencyValueFactory>(
    lowercased: StaticString? = nil,
    defaultValueFactory: T.Type
) = #externalMacro(
    module: "GlobalDependenciesMacros",
    type: "DependencyMacro"
)

/**
 Variant of the `Dependency` macro that does not take a default value factory type.

 If the default value type for the dependency implementation is named `Default<ProtocolName>Factory` you can use this
 variant of the macro and it will catch on it.

 Because there is no generic argument it has to be declared separately from the version with a default value type as
 the compiler wouldn't know what type to use without the presence of the parameter that uses it.

 Otherwise the documentation of the fully featured macro applies to its behavior.
 - Parameters
   - lowercased: Optional name of the dependency access property, to be used if it is different than `name` with its
 first letter in lowercase.
 */
@attached(peer, names: suffixed(Dependency), suffixed(DependencyKey))
@attached(member, names: named(Dependency), named(DependencyKey))
public macro Dependency(lowercased: StaticString? = nil) = #externalMacro(
    module: "GlobalDependenciesMacros",
    type: "DependencyMacro"
)
